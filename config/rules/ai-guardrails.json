{
  "version": "2.0.0",
  "description": "Reglas específicas para prevenir antipatrones de IA al codificar",
  
  "context_management": {
    "mandatory_reads_before_coding": [
      ".context/project-state.json",
      "dev-docs/domain/ubiquitous-language.md",
      "dev-docs/task.md (current task only)"
    ],
    "mandatory_updates_after_coding": [
      ".context/project-state.json (ai_context.last_session_summary)",
      "dev-docs/task.md (task status)",
      ".context/decision-log.json (if architectural decision made)"
    ],
    "context_window_strategy": "Priorizar: 1) Reglas, 2) Domain model, 3) Current task, 4) Related code"
  },

  "anti_patterns_prevention": {
    "over_engineering": {
      "rules": [
        "PROHIBIDO: Crear abstracción antes del 3er uso (Rule of Three)",
        "PROHIBIDO: Interfaces con una sola implementación sin justificación en ADR",
        "PROHIBIDO: Patrones de diseño sin problema concreto que resolver",
        "OBLIGATORIO: YAGNI - implementar SOLO lo que la task actual requiere"
      ],
      "validation": "Cada abstracción debe tener comentario explicando por qué existe"
    },
    
    "premature_optimization": {
      "rules": [
        "PROHIBIDO: Optimizaciones sin benchmark que demuestre problema",
        "PROHIBIDO: Caching sin mediciones de performance",
        "OBLIGATORIO: Make it work, make it right, make it fast (en ese orden)"
      ],
      "exceptions": "Big-O complexity puede considerarse en diseño inicial"
    },

    "context_loss": {
      "rules": [
        "OBLIGATORIO: Leer project-state.json antes de CADA sesión",
        "OBLIGATORIO: Actualizar ai_context.last_session_summary al terminar",
        "PROHIBIDO: Asumir conocimiento de sesiones anteriores sin verificar",
        "OBLIGATORIO: Si duda sobre decisión anterior, consultar ADRs"
      ],
      "triggers": [
        "Nueva sesión de IA → Leer .context/",
        "Código existente contradice expectativas → Buscar en decision-log"
      ]
    },

    "verbosity": {
      "rules": [
        "PROHIBIDO: Comentarios que repiten lo que el código dice",
        "PROHIBIDO: Nombres de variables excesivamente largos (max 3 palabras)",
        "OBLIGATORIO: Self-documenting code sobre comentarios",
        "PERMITIDO: Comentarios que explican POR QUÉ, no QUÉ"
      ],
      "examples": {
        "bad": "// Set user name to the name parameter\nuser.name = name;",
        "good": "// Name must be set before validation per GDPR requirements\nuser.name = name;"
      }
    },

    "copy_paste_coding": {
      "rules": [
        "PROHIBIDO: Duplicar lógica más de 2 veces sin refactor",
        "OBLIGATORIO: DRY después del segundo uso",
        "PROHIBIDO: Copiar código de internet sin entender",
        "OBLIGATORIO: Adaptar código copiado al estilo del proyecto"
      ]
    },

    "incomplete_error_handling": {
      "rules": [
        "PROHIBIDO: try-catch vacío o con solo console.log",
        "OBLIGATORIO: Todo error debe tener: tipo específico, mensaje, contexto",
        "OBLIGATORIO: Errores de dominio deben ser domain exceptions",
        "PROHIBIDO: Excepciones genéricas para errores de negocio"
      ]
    },

    "test_theater": {
      "description": "Tests que dan coverage pero no validan comportamiento",
      "rules": [
        "PROHIBIDO: Tests que solo llaman métodos sin asserts significativos",
        "PROHIBIDO: Tests con nombres genéricos (test1, testMethod)",
        "OBLIGATORIO: Cada test debe fallar si se rompe comportamiento específico",
        "OBLIGATORIO: Tests deben documentar comportamiento esperado"
      ],
      "red_flags": [
        "100% coverage pero bugs en producción",
        "Tests que nunca fallan incluso con bugs obvios",
        "Mocks que devuelven siempre valores dummy"
      ]
    },

    "god_objects": {
      "rules": [
        "PROHIBIDO: Clases con >7 responsabilidades (métodos públicos)",
        "PROHIBIDO: Archivos con >300 líneas sin justificación",
        "OBLIGATORIO: Single Responsibility Principle estricto",
        "TRIGGER: Si clase tiene 'Manager', 'Handler', 'Service' → REVISAR responsabilidades"
      ]
    },

    "anemic_domain": {
      "rules": [
        "PROHIBIDO: Entities que solo tienen getters/setters",
        "OBLIGATORIO: Lógica de negocio DEBE estar en domain layer",
        "OBLIGATORIO: Aggregates deben proteger invariantes",
        "PROHIBIDO: Validaciones de negocio en application layer"
      ]
    }
  },

  "incremental_development": {
    "rules": [
      "OBLIGATORIO: Commits cada 30 min o al completar subtarea",
      "OBLIGATORIO: Cada commit debe dejar proyecto en estado funcional",
      "PROHIBIDO: Commits con >500 líneas cambiadas",
      "OBLIGATORIO: Feature flags para features incompletas en main"
    ],
    "commit_message_format": "type(scope): description\n\nBody explaining WHY\n\nRefs: TASK-XXX"
  },

  "code_generation_safety": {
    "rules": [
      "PROHIBIDO: Generar código de seguridad (auth, crypto) sin revisión humana",
      "PROHIBIDO: Generar SQL dinámico sin prepared statements",
      "PROHIBIDO: Generar código con secrets hardcodeados",
      "OBLIGATORIO: TODO comments para código que requiere revisión humana"
    ],
    "human_review_required": [
      "Authentication/Authorization logic",
      "Cryptography implementation",
      "Payment processing",
      "Data deletion/privacy",
      "Security-sensitive configurations"
    ]
  },

  "refactoring_discipline": {
    "when_to_refactor": [
      "Después de hacer test pasar (Green phase de TDD)",
      "Al encontrar código duplicado por 3ra vez",
      "Cuando complejidad ciclomática > 10",
      "Cuando test es difícil de escribir (señal de mal diseño)"
    ],
    "when_NOT_to_refactor": [
      "Durante implementación de feature (finish first)",
      "Sin tests que cubran el código",
      "Código que cambiará pronto por otros motivos",
      "Sin comprender el código actual"
    ]
  },

  "ai_assistance_boundaries": {
    "ai_can_autonomously": [
      "Implementar tests para lógica nueva",
      "Refactorizar código con tests existentes",
      "Aplicar linting/formatting",
      "Generar código boilerplate estándar"
    ],
    "ai_must_consult_human": [
      "Cambios arquitectónicos significativos",
      "Decisiones sobre tradeoffs de seguridad/performance",
      "Modificación de contratos públicos/APIs",
      "Interpretación de requisitos de negocio ambiguos"
    ],
    "ai_never_does": [
      "Eliminar tests sin entender por qué fallan",
      "Commentar código que no compila en lugar de arreglarlo",
      "Cambiar reglas en config/ sin aprobación",
      "Commit código con TODOs en lógica crítica"
    ]
  }
}
